// Generated by Molecule 0.7.5

use molecule :: prelude :: * ;
use super :: foo :: * ;
# [derive (Clone)] pub struct B42 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for B42 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for B42 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for B42 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for B42 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; B42 :: new_unchecked (v) } } impl B42 { const DEFAULT_VALUE : [u8 ; 42] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 42 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 42 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn nth32 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (32 .. 33)) } pub fn nth33 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (33 .. 34)) } pub fn nth34 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (34 .. 35)) } pub fn nth35 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (35 .. 36)) } pub fn nth36 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (36 .. 37)) } pub fn nth37 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (37 .. 38)) } pub fn nth38 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (38 .. 39)) } pub fn nth39 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (39 .. 40)) } pub fn nth40 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (40 .. 41)) } pub fn nth41 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (41 .. 42)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> B42Reader < 'r > { B42Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for B42 { type Builder = B42Builder ; const NAME : & 'static str = "B42" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { B42 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { B42Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { B42Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () , self . nth32 () , self . nth33 () , self . nth34 () , self . nth35 () , self . nth36 () , self . nth37 () , self . nth38 () , self . nth39 () , self . nth40 () , self . nth41 () ,]) } }
# [derive (Clone , Copy)] pub struct B42Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for B42Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for B42Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for B42Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > B42Reader < 'r > { pub const TOTAL_SIZE : usize = 42 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 42 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn nth32 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [32 .. 33]) } pub fn nth33 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [33 .. 34]) } pub fn nth34 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [34 .. 35]) } pub fn nth35 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [35 .. 36]) } pub fn nth36 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [36 .. 37]) } pub fn nth37 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [37 .. 38]) } pub fn nth38 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [38 .. 39]) } pub fn nth39 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [39 .. 40]) } pub fn nth40 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [40 .. 41]) } pub fn nth41 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [41 .. 42]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for B42Reader < 'r > { type Entity = B42 ; const NAME : & 'static str = "B42Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { B42Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
pub struct B42Builder (pub (crate) [Byte ; 42]) ; impl :: core :: fmt :: Debug for B42Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for B42Builder { fn default () -> Self { B42Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl B42Builder { pub const TOTAL_SIZE : usize = 42 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 42 ; pub fn set (mut self , v : [Byte ; 42]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } pub fn nth16 (mut self , v : Byte) -> Self { self . 0 [16] = v ; self } pub fn nth17 (mut self , v : Byte) -> Self { self . 0 [17] = v ; self } pub fn nth18 (mut self , v : Byte) -> Self { self . 0 [18] = v ; self } pub fn nth19 (mut self , v : Byte) -> Self { self . 0 [19] = v ; self } pub fn nth20 (mut self , v : Byte) -> Self { self . 0 [20] = v ; self } pub fn nth21 (mut self , v : Byte) -> Self { self . 0 [21] = v ; self } pub fn nth22 (mut self , v : Byte) -> Self { self . 0 [22] = v ; self } pub fn nth23 (mut self , v : Byte) -> Self { self . 0 [23] = v ; self } pub fn nth24 (mut self , v : Byte) -> Self { self . 0 [24] = v ; self } pub fn nth25 (mut self , v : Byte) -> Self { self . 0 [25] = v ; self } pub fn nth26 (mut self , v : Byte) -> Self { self . 0 [26] = v ; self } pub fn nth27 (mut self , v : Byte) -> Self { self . 0 [27] = v ; self } pub fn nth28 (mut self , v : Byte) -> Self { self . 0 [28] = v ; self } pub fn nth29 (mut self , v : Byte) -> Self { self . 0 [29] = v ; self } pub fn nth30 (mut self , v : Byte) -> Self { self . 0 [30] = v ; self } pub fn nth31 (mut self , v : Byte) -> Self { self . 0 [31] = v ; self } pub fn nth32 (mut self , v : Byte) -> Self { self . 0 [32] = v ; self } pub fn nth33 (mut self , v : Byte) -> Self { self . 0 [33] = v ; self } pub fn nth34 (mut self , v : Byte) -> Self { self . 0 [34] = v ; self } pub fn nth35 (mut self , v : Byte) -> Self { self . 0 [35] = v ; self } pub fn nth36 (mut self , v : Byte) -> Self { self . 0 [36] = v ; self } pub fn nth37 (mut self , v : Byte) -> Self { self . 0 [37] = v ; self } pub fn nth38 (mut self , v : Byte) -> Self { self . 0 [38] = v ; self } pub fn nth39 (mut self , v : Byte) -> Self { self . 0 [39] = v ; self } pub fn nth40 (mut self , v : Byte) -> Self { self . 0 [40] = v ; self } pub fn nth41 (mut self , v : Byte) -> Self { self . 0 [41] = v ; self } } impl molecule :: prelude :: Builder for B42Builder { type Entity = B42 ; const NAME : & 'static str = "B42Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; writer . write_all (self . 0 [32] . as_slice ()) ? ; writer . write_all (self . 0 [33] . as_slice ()) ? ; writer . write_all (self . 0 [34] . as_slice ()) ? ; writer . write_all (self . 0 [35] . as_slice ()) ? ; writer . write_all (self . 0 [36] . as_slice ()) ? ; writer . write_all (self . 0 [37] . as_slice ()) ? ; writer . write_all (self . 0 [38] . as_slice ()) ? ; writer . write_all (self . 0 [39] . as_slice ()) ? ; writer . write_all (self . 0 [40] . as_slice ()) ? ; writer . write_all (self . 0 [41] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; B42 :: new_unchecked (inner . into ()) } }
# [derive (Clone)] pub struct Bar (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bar { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bar { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bar { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "field1" , self . field1 ()) ? ; write ! (f , ", {}: {}" , "field2" , self . field2 ()) ? ; write ! (f , " }}") } } impl :: core :: default :: Default for Bar { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Bar :: new_unchecked (v) } } impl Bar { const DEFAULT_VALUE : [u8 ; 74] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 74 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 42 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn field1 (& self) -> F32 { F32 :: new_unchecked (self . 0 . slice (0 .. 32)) } pub fn field2 (& self) -> B42 { B42 :: new_unchecked (self . 0 . slice (32 .. 74)) } pub fn as_reader < 'r > (& 'r self) -> BarReader < 'r > { BarReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bar { type Builder = BarBuilder ; const NAME : & 'static str = "Bar" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bar (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BarReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BarReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . field1 (self . field1 ()) . field2 (self . field2 ()) } }
# [derive (Clone , Copy)] pub struct BarReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BarReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BarReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BarReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} {{ " , Self :: NAME) ? ; write ! (f , "{}: {}" , "field1" , self . field1 ()) ? ; write ! (f , ", {}: {}" , "field2" , self . field2 ()) ? ; write ! (f , " }}") } } impl < 'r > BarReader < 'r > { pub const TOTAL_SIZE : usize = 74 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 42 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn field1 (& self) -> F32Reader < 'r > { F32Reader :: new_unchecked (& self . as_slice () [0 .. 32]) } pub fn field2 (& self) -> B42Reader < 'r > { B42Reader :: new_unchecked (& self . as_slice () [32 .. 74]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for BarReader < 'r > { type Entity = Bar ; const NAME : & 'static str = "BarReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BarReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Debug , Default)] pub struct BarBuilder { pub (crate) field1 : F32 , pub (crate) field2 : B42 , } impl BarBuilder { pub const TOTAL_SIZE : usize = 74 ; pub const FIELD_SIZES : [usize ; 2] = [32 , 42 ,] ; pub const FIELD_COUNT : usize = 2 ; pub fn field1 (mut self , v : F32) -> Self { self . field1 = v ; self } pub fn field2 (mut self , v : B42) -> Self { self . field2 = v ; self } } impl molecule :: prelude :: Builder for BarBuilder { type Entity = Bar ; const NAME : & 'static str = "BarBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . field1 . as_slice ()) ? ; writer . write_all (self . field2 . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bar :: new_unchecked (inner . into ()) } }
